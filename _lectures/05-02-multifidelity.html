---
title: "Multifidelity Modelling"
abstract: "<p>This week we introduce multifidelity modelling. We use surrogate models to capture different qualities of information from different simulations.</p>"
author:
- given: Neil D.
  family: Lawrence
  url: http://inverseprobability.com
  institute: University of Cambridge
  twitter: lawrennd
  gscholar: r3SJcvoAAAAJ
  orcid: 
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_mlphysical/multifidelity.md
date: 2022-11-08
published: 2022-11-08
time: "10:00"
week: 5
session: 2
reveal: 05-02-multifidelity.slides.html
transition: None
ipynb: 05-02-multifidelity.ipynb
youtube: "0aBhHkBaBdE"
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_mlphysical/multifidelity.md
layout: lecture
categories:
- notes
---



<!-- Do not edit this file locally. -->
<!---->
<!-- Do not edit this file locally. -->
<!-- Do not edit this file locally. -->
<!-- The last names to be defined. Should be defined entirely in terms of macros from above-->
<!--

-->
<h2 id="setup">Setup</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_notebooks/includes/notebook-setup.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_notebooks/includes/notebook-setup.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<!--setupplotcode{import seaborn as sns
sns.set_style('darkgrid')
sns.set_context('paper')
sns.set_palette('colorblind')}-->
<h2 id="notutils">notutils</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/notutils-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/notutils-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>This small package is a helper package for various notebook utilities used</p>
<p>The software can be installed using</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install notutils</span></code></pre></div>
<p>from the command prompt where you can access your python installation.</p>
<p>The code is also available on GitHub: <a href="https://github.com/lawrennd/notutils" class="uri">https://github.com/lawrennd/notutils</a></p>
<p>Once <code>notutils</code> is installed, it can be imported in the usual manner.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> notutils</span></code></pre></div>
<h2 id="pods">pods</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/pods-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/pods-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In Sheffield we created a suite of software tools for ‘Open Data Science.’ Open data science is an approach to sharing code, models and data that should make it easier for companies, health professionals and scientists to gain access to data science techniques.</p>
<p>You can also check this blog post on <a href="http://inverseprobability.com/2014/07/01/open-data-science">Open Data Science</a>.</p>
<p>The software can be installed using</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install pods</span></code></pre></div>
<p>from the command prompt where you can access your python installation.</p>
<p>The code is also available on GitHub: <a href="https://github.com/lawrennd/ods" class="uri">https://github.com/lawrennd/ods</a></p>
<p>Once <code>pods</code> is installed, it can be imported in the usual manner.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pods</span></code></pre></div>
<h2 id="mlai">mlai</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/mlai-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/mlai-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>The <code>mlai</code> software is a suite of helper functions for teaching and demonstrating machine learning algorithms. It was first used in the Machine Learning and Adaptive Intelligence course in Sheffield in 2013.</p>
<p>The software can be installed using</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install mlai</span></code></pre></div>
<p>from the command prompt where you can access your python installation.</p>
<p>The code is also available on GitHub: <a href="https://github.com/lawrennd/mlai" class="uri">https://github.com/lawrennd/mlai</a></p>
<p>Once <code>mlai</code> is installed, it can be imported in the usual manner.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install gpy</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install pyDOE</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install emukit</span></code></pre></div>
<h1 id="an-introduction-to-multi-fidelity-modeling-in-emukit">An Introduction to Multi-fidelity Modeling in Emukit</h1>
<p>A reminder from our lecture on Emulation. This diagram implies that we might expect our statistical emulator to be able to ‘adjudicate’ between simulations with different fidelity.</p>
<div class="figure">
<div id="statistical-emulation-6-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/statistical-emulation004.svg" width="80%" style=" ">
</object>
</div>
<div id="statistical-emulation-6-magnify" class="magnify" onclick="magnifyFigure(&#39;statistical-emulation-6&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="statistical-emulation-6-caption" class="caption-frame">
<p>Figure: A statistical emulator is a system that reconstructs the simulation with a statistical model. As well as reconstructing the simulation, a statistical emulator can be used to correlate with the real world.</p>
</div>
</div>
<h2 id="overview">Overview</h2>
<p>This section is based on the <a href="https://github.com/EmuKit/emukit/blob/master/notebooks/Emukit-tutorial-multi-fidelity-bayesian-optimization.ipynb">Emukit multifidelity tutorial found here</a> and written by Javier Gonzalez, Mark Pullin, Oleg Ponomarev and David-Elias Künstle.</p>
<p>A common issue encountered when applying machine learning to environmental sciences and engineering problems is the difficulty or cost required to obtain sufficient data for building robust models. Possible examples include aerospace and nautical engineering, where it is both infeasible and prohibitively expensive to run a vast number of experiments using the actual vehicle. Even when there is no physical artifact involved, such as in climate modeling, data may still be hard to obtain when these can only be collected by running an expensive computer experiment, where the time required to acquire an individual data sample restricts the volume of data that can later be used for modeling.</p>
<p>Constructing a reliable model when only few observations are available is challenging, which is why it is common practice to develop <em>simulators</em> of the actual system, from which data points can be more easily obtained. In engineering applications, such simulators often take the form of Computational Fluid Dynamics (CFD) tools which approximate the behaviour of the true artifact for a given design or configuration. However, although it is now possible to obtain more data samples, it is highly unlikely that these simulators model the true system exactly; instead, these are expected to contain some degree of bias and/or noise.</p>
<p>From the above, one can deduce that naively combining observations from multiple information sources could result in the model giving biased predictions which do not accurately reflect the true problem. To this end, <em>multi-fidelity models</em> are designed to augment the limited true observations available with cheaply-obtained approximations in a principled manner. In such models, observations obtained from the true source are referred to as <em>high-fidelity</em> observations, whereas approximations are denoted as being <em>low-fidelity</em>. These low-fidelity observations are then systemically combined with the more accurate (but limited) observations in order to predict the high-fidelity output more effectively. Note than we can generally combine information from multiple lower fidelity sources, which can all be seen as auxiliary tasks in support of a single primary task.</p>
<p>In this notebook, we shall investigate a selection of multi-fidelity models based on Gaussian processes which are readily available in <code>EmuKit</code>. We start by investigating the traditional linear multi-fidelity model as proposed in <span class="citation" data-cites="Kennedy-predicting00">(Kennedy and O’Hagan, 2000)</span>. Subsequently, we shall illustrate why this model can be unsuitable when the mapping from low to high-fidelity observations is nonlinear, and demonstrate how an alternate model proposed in <span class="citation" data-cites="Pedikaris:nonlinear17">Paris Perdikaris et al. (2017)</span> can alleviate this issue. The examples presented in this notebook can then be easily adapted to a variety of problem settings.</p>
<h2 id="linear-multi-fidelity-model">Linear multi-fidelity model</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/emukit-linear-multifidelity.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/emukit-linear-multifidelity.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>The linear multi-fidelity model proposed in <span class="citation" data-cites="Kennedy-predicting00">Kennedy and O’Hagan (2000)</span> is widely viewed as a reference point for all such models. In this model, the high-fidelity (true) function is modeled as a scaled sum of the low-fidelity function plus an error term: <span class="math display">\[
f_{\text{high}}(x) = f_{\text{err}}(x) + \rho \,f_{\text{low}}(x)
\]</span> In this equation, <span class="math inline">\(f_{\text{low}}(x)\)</span> is taken to be a Gaussian process modeling the outputs of the lower fidelity function, while <span class="math inline">\(\rho\)</span> is a scaling factor indicating the magnitude of the correlation to the high-fidelity data. Setting this to 0 implies that there is no correlation between observations at different fidelities. Meanwhile, <span class="math inline">\(f_{\text{err}}(x)\)</span> denotes yet another Gaussian process which models the bias term for the high-fidelity data. Note that <span class="math inline">\(f_{\text{err}}(x)\)</span> and <span class="math inline">\(f_{\text{low}}(x)\)</span> are assumed to be independent processes which are only related by the equation given above.</p>
<p><strong>Note</strong>: While we shall limit our explanation to the case of two fidelities, this set-up can easily be generalized to cater for <span class="math inline">\(T\)</span> fidelities as follows: <span class="math display">\[
f_{t}(x) = f_{t}(x) + \rho_{t-1} \,f_{t-1}(x), \quad t=1,\dots, T
\]</span></p>
<p>If the training points are sorted such that the low and high-fidelity points are grouped together: <span class="math display">\[
\begin{pmatrix}
\mathbf{X}_{\text{low}} \\
\mathbf{X}_{\text{high}}
\end{pmatrix}
\]</span></p>
<p>we can express the model as a single Gaussian process having the following prior. <span class="math display">\[
\begin{bmatrix}
f_{\text{low}}\left(h\right)\\
f_{\text{high}}\left(h\right)
\end{bmatrix}
\sim
GP
\begin{pmatrix}
\begin{bmatrix}
0 \\ 0
\end{bmatrix},
\begin{bmatrix}
k_{\text{low}} &amp; \rho k_{\text{low}} \\
\rho k_{\text{low}} &amp; \rho^2 k_{\text{low}} + k_{\text{err}}
\end{bmatrix}
\end{pmatrix}
\]</span></p>
<h3 id="linear-multi-fidelity-modeling-in-emukit">Linear multi-fidelity modeling in Emukit</h3>
<p>As a first example of how the linear multi-fidelity model implemented in <code>Emukit</code> <code>emukit.multi_fidelity.models.GPyLinearMultiFidelityModel</code> can be used, we shall consider the two-fidelity Forrester function. This benchmark is frequently used to illustrate the capabilities of multi-fidelity models.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">20</span>)</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> emukit.multi_fidelity</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> emukit.test_functions</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.model_wrappers.gpy_model_wrappers <span class="im">import</span> GPyMultiOutputWrapper</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.multi_fidelity.models <span class="im">import</span> GPyLinearMultiFidelityModel</span></code></pre></div>
<p>Generate samples from the Forrester function</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>high_fidelity <span class="op">=</span> emukit.test_functions.forrester.forrester</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>low_fidelity <span class="op">=</span> emukit.test_functions.forrester.forrester_low</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">200</span>)[:, np.newaxis]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>y_plot_l <span class="op">=</span> low_fidelity(x_plot)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>y_plot_h <span class="op">=</span> high_fidelity(x_plot)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>x_train_l <span class="op">=</span> np.atleast_2d(np.random.rand(<span class="dv">12</span>)).T</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>x_train_h <span class="op">=</span> np.atleast_2d(np.random.permutation(x_train_l)[:<span class="dv">6</span>])</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>y_train_l <span class="op">=</span> low_fidelity(x_train_l)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>y_train_h <span class="op">=</span> high_fidelity(x_train_h)</span></code></pre></div>
<p>The inputs to the models are expected to take the form of ndarrays where the last column indicates the fidelity of the observed points.</p>
<p>Although only the input points, <span class="math inline">\(X\)</span>, are augmented with the fidelity level, the observed outputs <span class="math inline">\(Y\)</span> must also be converted to array form.</p>
<p>For example, a dataset consisting of 3 low-fidelity points and 2 high-fidelity points would be represented as follows, where the input is three-dimensional while the output is one-dimensional: <span class="math display">\[
\mathbf{X}= \begin{pmatrix}
x_{\text{low};0}^0 &amp; x_{\text{low};0}^1 &amp; x_{\text{low};0}^2 &amp; 0\\
x_{\text{low};1}^0 &amp; x_{\text{low};1}^1 &amp; x_{\text{low};1}^2 &amp; 0\\
x_{\text{low};2}^0 &amp; x_{\text{low};2}^1 &amp; x_{\text{low};2}^2 &amp; 0\\
x_{\text{high};0}^0 &amp; x_{\text{high};0}^1 &amp; x_{\text{high};0}^2 &amp; 1\\
x_{\text{high};1}^0 &amp; x_{\text{high};1}^1 &amp; x_{\text{high};1}^2 &amp; 1
\end{pmatrix}\quad
\mathbf{Y}= \begin{pmatrix}
y_{\text{low};0}\\
y_{\text{low};1}\\
y_{\text{low};2}\\
y_{\text{high};0}\\
y_{\text{high};1}
\end{pmatrix}
\]</span> This is a representation we first developed for the <code>GPy</code> software. It allows for a lot of flexibility for Gaussian processes that describe multiple correlated functions, like the ‘multi-fidelity’ model of <span class="citation" data-cites="Kennedy-predicting00">Kennedy and O’Hagan (2000)</span>.</p>
<p>As an aside there is quite a lot of history to modelling Gaussian processes which represent multiple output functions. Back in 2009, with Mauricio Alvarez, we organized a series of workshops where we worked across the geostatistics, the emulation and the machine learning communities to build understanding. You can see <a href="http://gpss.cc/slim09/schedule.html">details of the first of these workshops (held in Manchester) here</a>. The second of these workshops also integrated ideas from the classical kernel community, and was held at NeurIPS in 2009 in collaboration with <a href="https://www.dibris.unige.it/en/rosasco-lorenzo">Lorenzo Rosasco</a>, you can find the <a href="http://gpss.cc/mock09/">workshop page here</a>. We summarized the conclusions from those meetings in a <a href="https://arxiv.org/abs/1106.6251">review paper led by Mauricio, that you can find here</a> <span class="citation" data-cites="Alvarez:vector12">(Álvarez et al., 2012)</span>.</p>
<p>In that terminology the multifidelity model we’re using here is known as a “intrinsic coregionalisation model” and it is one of the simplest types of multi-output Gaussian processes you can build.</p>
<p>Mauricio’s thesis <span class="citation" data-cites="Alvarez:thesis11">(Álvarez, 2011)</span> focused on particular multiple output covariances derived from physical information embedded in the system, such as differential equations. See e.g., <span class="citation" data-cites="Alvarez:llfm13">Álvarez et al. (2013)</span> or <span class="citation" data-cites="Lawrence:transcriptionalGP06">Lawrence et al. (n.d.)</span> for an application.</p>
<p>A similar procedure must be carried out for obtaining predictions at new test points, whereby the fidelity indicated in the column then indicates the fidelity at which the function must be predicted for a designated point.</p>
<p>For convenience of use, we provide helper methods for easily converting between a list of arrays (ordered from the lowest to the highest fidelity) and the required ndarray representation. This is found in <code>emukit.multi_fidelity.convert_lists_to_array</code>.</p>
<p>Convert lists of arrays to ndarrays augmented with fidelity indicators.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.multi_fidelity.convert_lists_to_array <span class="im">import</span> convert_x_list_to_array, convert_xy_lists_to_arrays</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>X_train, Y_train <span class="op">=</span> convert_xy_lists_to_arrays([x_train_l, x_train_h], </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                                                    [y_train_l, y_train_h])</span></code></pre></div>
<p>Plot the original functions.</p>
<div class="figure">
<div id="high-and-low-fidelity-forrester-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/high-and-low-fidelity-forrester.svg" width="80%" style=" ">
</object>
</div>
<div id="high-and-low-fidelity-forrester-magnify" class="magnify" onclick="magnifyFigure(&#39;high-and-low-fidelity-forrester&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="high-and-low-fidelity-forrester-caption" class="caption-frame">
<p>Figure: High and low fidelity Forrester functions.</p>
</div>
</div>
<p>Observe that in the example above we restrict our observations to 12 from the lower-fidelity function and only 6 from the high-fidelity function. As we shall demonstrate further below, fitting a standard GP model to the few high-fidelity observations is unlikely to result in an acceptable fit, which is why we shall instead consider the linear multi-fidelity model presented in this section.</p>
<p>Below we fit a linear multi-fidelity model to the available low and high-fidelity observations. Given the smoothness of the functions, we opt to use an exponentiated quadratic kernel for both the bias and correlation components of the model.</p>
<p><strong>Note</strong>: The model implementation defaults to a <code>MixedNoise</code> noise likelihood whereby there is independent Gaussian noise for each fidelity.</p>
<p>This can be modified upfront using the ‘likelihood’ parameter in the model constructor, or by updating them directly after the model has been created. In the example below, we choose to fix the noise to ‘0’ for both fidelities to reflect that the observations are exact.</p>
<p>Construct a linear multi-fidelity model.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>kernels <span class="op">=</span> [GPy.kern.RBF(<span class="dv">1</span>), GPy.kern.RBF(<span class="dv">1</span>)]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>lin_mf_kernel <span class="op">=</span> emukit.multi_fidelity.kernels.LinearMultiFidelityKernel(kernels)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model <span class="op">=</span> GPyLinearMultiFidelityModel(X_train, Y_train, lin_mf_kernel, n_fidelities<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model.mixed_noise.Gaussian_noise.fix(<span class="dv">0</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model.mixed_noise.Gaussian_noise_1.fix(<span class="dv">0</span>)</span></code></pre></div>
<p>Wrap the model using the given <code>GPyMultiOutputWrapper</code></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>lin_mf_model <span class="op">=</span> GPyMultiOutputWrapper(gpy_lin_mf_model, <span class="dv">2</span>, n_optimization_restarts<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div>
<p>Fit the model</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>lin_mf_model.optimize()</span></code></pre></div>
<p>Convert x_plot to its ndarray representation.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>X_plot <span class="op">=</span> convert_x_list_to_array([x_plot, x_plot])</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>X_plot_l <span class="op">=</span> X_plot[:<span class="bu">len</span>(x_plot)]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>X_plot_h <span class="op">=</span> X_plot[<span class="bu">len</span>(x_plot):]</span></code></pre></div>
<p>Compute mean predictions and associated variance.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>lf_mean_lin_mf_model, lf_var_lin_mf_model <span class="op">=</span> lin_mf_model.predict(X_plot_l)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>lf_std_lin_mf_model <span class="op">=</span> np.sqrt(lf_var_lin_mf_model)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>hf_mean_lin_mf_model, hf_var_lin_mf_model <span class="op">=</span> lin_mf_model.predict(X_plot_h)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>hf_std_lin_mf_model <span class="op">=</span> np.sqrt(hf_var_lin_mf_model)</span></code></pre></div>
<p>Plot the posterior mean and variance.</p>
<div class="figure">
<div id="linear-multi-fidelity-model-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/linear-multi-fidelity-model.svg" width="80%" style=" ">
</object>
</div>
<div id="linear-multi-fidelity-model-magnify" class="magnify" onclick="magnifyFigure(&#39;linear-multi-fidelity-model&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="linear-multi-fidelity-model-caption" class="caption-frame">
<p>Figure: Linear multi-fidelity model fit to low and high-fidelity Forrester function</p>
</div>
</div>
<p>The above plot demonstrates how the multi-fidelity model learns the relationship between the low and high-fidelity observations to model both of the corresponding functions.</p>
<p>In this example, the posterior mean almost fits the true function exactly, while the associated uncertainty returned by the model is also appropriately small given the good fit.</p>
<h3 id="comparison-to-standard-gp">Comparison to standard GP</h3>
<p>In the absence of such a multi-fidelity model, a regular Gaussian process would have been fit exclusively to the high fidelity data.</p>
<p>As illustrated in the figure below, the resulting Gaussian process posterior yields a much worse fit to the data than that obtained by the multi-fidelity model. The uncertainty estimates are also poorly calibrated.</p>
<p>Create standard GP model using only high-fidelity data.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>kernel <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>high_gp_model <span class="op">=</span> GPy.models.GPRegression(x_train_h, y_train_h, kernel)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>high_gp_model.Gaussian_noise.fix(<span class="dv">0</span>)</span></code></pre></div>
<p>Fit the GP model.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>high_gp_model.optimize_restarts(<span class="dv">5</span>)</span></code></pre></div>
<p>Compute mean predictions and associated variance.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>hf_mean_high_gp_model, hf_var_high_gp_model  <span class="op">=</span> high_gp_model.predict(x_plot)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>hf_std_hf_gp_model <span class="op">=</span> np.sqrt(hf_var_high_gp_model)</span></code></pre></div>
<p>Plot the posterior mean and variance for the high-fidelity GP model.</p>
<div class="figure">
<div id="linear-multi-fidelity-high-fidelity-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/linear-multi-fidelity-high-fidelity-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="linear-multi-fidelity-high-fidelity-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;linear-multi-fidelity-high-fidelity-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="linear-multi-fidelity-high-fidelity-gp-caption" class="caption-frame">
<p>Figure: Comparison of linear multi-fidelity model and high fidelity GP</p>
</div>
</div>
<h2 id="nonlinear-multi-fidelity-model">Nonlinear multi-fidelity model</h2>
<p>Although the model described above works well when the mapping between the low and high-fidelity functions is linear, several issues may be encountered when this is not the case.</p>
<p>Consider the following example, where the low and high-fidelity functions are defined as follows: <span class="math display">\[
f_{\text{low}}(x) = \sin(8\pi x)
\]</span></p>
<p><span class="math display">\[
f_{\text{high}}(x) = \left(x- \sqrt{2}\right) \, f_{\text{low}}^2
\]</span></p>
<p>Generate data for nonlinear example.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>high_fidelity <span class="op">=</span> emukit.test_functions.non_linear_sin.nonlinear_sin_high</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>low_fidelity <span class="op">=</span> emukit.test_functions.non_linear_sin.nonlinear_sin_low</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">200</span>)[:, np.newaxis]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>y_plot_l <span class="op">=</span> low_fidelity(x_plot)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>y_plot_h <span class="op">=</span> high_fidelity(x_plot)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>n_low_fidelity_points <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>n_high_fidelity_points <span class="op">=</span> <span class="dv">14</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>x_train_l <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n_low_fidelity_points)[:, np.newaxis]</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>y_train_l <span class="op">=</span> low_fidelity(x_train_l)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>x_train_h <span class="op">=</span> x_train_l[::<span class="dv">4</span>, :]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>y_train_h <span class="op">=</span> high_fidelity(x_train_h)</span></code></pre></div>
<p>Convert lists of arrays to <code>ND-array</code>s augmented with fidelity indicators</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>X_train, Y_train <span class="op">=</span> convert_xy_lists_to_arrays([x_train_l, x_train_h], [y_train_l, y_train_h])</span></code></pre></div>
<div class="figure">
<div id="high-and-low-fidelity-functions-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/high-and-low-fidelity-functions.svg" width="80%" style=" ">
</object>
</div>
<div id="high-and-low-fidelity-functions-magnify" class="magnify" onclick="magnifyFigure(&#39;high-and-low-fidelity-functions&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="high-and-low-fidelity-functions-caption" class="caption-frame">
<p>Figure: High and low-fidelity functions</p>
</div>
</div>
<p>In this case, the mapping between the two functions is nonlinear, as can be observed by plotting the high-fidelity observations as a function of the lower fidelity observations.</p>
<div class="figure">
<div id="mapping-low-to-high-fidelity-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mapping-low-to-high-fidelity.svg" width="80%" style=" ">
</object>
</div>
<div id="mapping-low-to-high-fidelity-magnify" class="magnify" onclick="magnifyFigure(&#39;mapping-low-to-high-fidelity&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mapping-low-to-high-fidelity-caption" class="caption-frame">
<p>Figure: Mapping from low-fidelity to high-fidelity.</p>
</div>
</div>
<h3 id="failure-of-linear-multi-fidelity-model">Failure of linear multi-fidelity model</h3>
<p>Below we fit the linear multi-fidelity model to this new problem and plot the results.</p>
<p>Construct a linear multi-fidelity model.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>kernels <span class="op">=</span> [GPy.kern.RBF(<span class="dv">1</span>), GPy.kern.RBF(<span class="dv">1</span>)]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>lin_mf_kernel <span class="op">=</span> emukit.multi_fidelity.kernels.LinearMultiFidelityKernel(kernels)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model <span class="op">=</span> GPyLinearMultiFidelityModel(X_train, Y_train, lin_mf_kernel, n_fidelities<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model.mixed_noise.Gaussian_noise.fix(<span class="dv">0</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>gpy_lin_mf_model.mixed_noise.Gaussian_noise_1.fix(<span class="dv">0</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>lin_mf_model <span class="op">=</span> model <span class="op">=</span> GPyMultiOutputWrapper(gpy_lin_mf_model, <span class="dv">2</span>, n_optimization_restarts<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div>
<p>Fit the model</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>lin_mf_model.optimize()</span></code></pre></div>
<p>Convert test points to appropriate representation</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>X_plot <span class="op">=</span> convert_x_list_to_array([x_plot, x_plot])</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>X_plot_low <span class="op">=</span> X_plot[:<span class="dv">200</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>X_plot_high <span class="op">=</span> X_plot[<span class="dv">200</span>:]</span></code></pre></div>
<p>Compute mean and variance predictions</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>hf_mean_lin_mf_model, hf_var_lin_mf_model <span class="op">=</span> lin_mf_model.predict(X_plot_high)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>hf_std_lin_mf_model <span class="op">=</span> np.sqrt(hf_var_lin_mf_model)</span></code></pre></div>
<p>Compare linear and nonlinear model fits</p>
<div class="figure">
<div id="linear-multi-fidelity-model-fit-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/linear-multi-fidelity-model-fit.svg" width="80%" style=" ">
</object>
</div>
<div id="linear-multi-fidelity-model-fit-magnify" class="magnify" onclick="magnifyFigure(&#39;linear-multi-fidelity-model-fit&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="linear-multi-fidelity-model-fit-caption" class="caption-frame">
<p>Figure: Linear multi-fidelity model fit to high-fidelity function</p>
</div>
</div>
<p>As expected, the linear multi-fidelity model was unable to capture the nonlinear relationship between the low and high-fidelity data. Consequently, the resulting fit of the true function is also poor.</p>
<h3 id="nonlinear-multi-fidelity-model-1">Nonlinear Multi-fidelity model</h3>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/emukit-nonlinear-multifidelity.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/emukit-nonlinear-multifidelity.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In view of the deficiencies of the linear multi-fidelity model, a nonlinear multi-fidelity model is proposed in <span class="citation" data-cites="Pedikaris:nonlinear17">Paris Perdikaris et al. (2017)</span> to better capture these correlations. This nonlinear model is constructed as follows: <span class="math display">\[ 
f_{\text{high}}(x) = \rho( \, f_{\text{low}}(x)) + \delta(x) 
\]</span> Replacing the linear scaling factor with a non-deterministic function results in a model which can thus capture the nonlinear relationship between the fidelities.</p>
<p>This model is implemented in Emukit as <code>emukit.multi_fidelity.models.NonLinearModel</code>.</p>
<p>It is defined in a sequential manner where a Gaussian process model is trained for every set of fidelity data available. Once again, we manually fix the noise parameter for each model to 0. The parameters of the two Gaussian processes are then optimized sequentially, starting from the low-fidelity.</p>
<p>Create nonlinear model.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.multi_fidelity.models.non_linear_multi_fidelity_model <span class="im">import</span> make_non_linear_kernels, NonLinearMultiFidelityModel</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>base_kernel <span class="op">=</span> GPy.kern.RBF</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>kernels <span class="op">=</span> make_non_linear_kernels(base_kernel, <span class="dv">2</span>, X_train.shape[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>nonlin_mf_model <span class="op">=</span> NonLinearMultiFidelityModel(X_train, Y_train, n_fidelities<span class="op">=</span><span class="dv">2</span>, kernels<span class="op">=</span>kernels, </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                                              verbose<span class="op">=</span><span class="va">True</span>, optimization_restarts<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m <span class="kw">in</span> nonlin_mf_model.models:</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    m.Gaussian_noise.variance.fix(<span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>nonlin_mf_model.optimize()</span></code></pre></div>
<p>Now we compute the mean and variance predictions</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>hf_mean_nonlin_mf_model, hf_var_nonlin_mf_model <span class="op">=</span> nonlin_mf_model.predict(X_plot_high)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>hf_std_nonlin_mf_model <span class="op">=</span> np.sqrt(hf_var_nonlin_mf_model)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>lf_mean_nonlin_mf_model, lf_var_nonlin_mf_model <span class="op">=</span> nonlin_mf_model.predict(X_plot_low)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>lf_std_nonlin_mf_model <span class="op">=</span> np.sqrt(lf_var_nonlin_mf_model)</span></code></pre></div>
<div class="figure">
<div id="-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/nonlinear-multi-fidelity-model-fit.svg" width="80%" style=" ">
</object>
</div>
<div id="-magnify" class="magnify" onclick="magnifyFigure(&#39;&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="-caption" class="caption-frame">
<p>Figure: Nonlinear multi-fidelity model fit to low and high-fidelity functions.</p>
</div>
</div>
<p>Fitting the nonlinear fidelity model to the available data very closely fits the high-fidelity function while also fitting the low-fidelity function exactly. This is a vast improvement over the results obtained using the linear model. We can also confirm that the model is properly capturing the correlation between the low and high-fidelity observations by plotting the mapping learned by the model to the true mapping shown earlier.</p>
<div class="figure">
<div id="mapping-low-fidelity-to-high-fidelity-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mapping-low-fidelity-to-high-fidelity.svg" width="80%" style=" ">
</object>
</div>
<div id="mapping-low-fidelity-to-high-fidelity-magnify" class="magnify" onclick="magnifyFigure(&#39;mapping-low-fidelity-to-high-fidelity&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mapping-low-fidelity-to-high-fidelity-caption" class="caption-frame">
<p>Figure: Mapping from low fidelity to high fidelity</p>
</div>
</div>
<h2 id="deep-gaussian-processes">Deep Gaussian Processes</h2>
<div class="centered" style="">
<svg viewBox="0 0 200 200" style="width:15%">
<defs> <clipPath id="clip0">
<style>
circle {
  fill: black;
}
</style>
<circle cx="100" cy="100" r="100"/> </clipPath> </defs>
<title>
Andreas Damianou
</title>
<image preserveAspectRatio="xMinYMin slice" width="100%" xlink:href="https://mlatcl.github.io/mlphysical/./slides/diagrams//people/andreas-damianou.png" clip-path="url(#clip0)"/>
</svg>
</div>
<p>These non-linear multi-fidelity models are an example of composing Gaussian processes together. This type of non-linear relationship leads to what we refer to as a Deep Gaussian process <span class="citation" data-cites="Damianou:deepgp13 Lawrence:hgplvm07">(Damianou and Lawrence, 2013; Lawrence and Moore, 2007)</span> which Andreas Damianou worked on for his PhD thesis <span class="citation" data-cites="Damianou:thesis2015">(Damianou, 2015)</span>.</p>
<p>These ideas lead to the notion of ‘deep emulation,’ where a number of emulators are chained together to represent a system.</p>
<h2 id="stochastic-process-composition">Stochastic Process Composition</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stochastic-process-composition.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stochastic-process-composition.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p><span class="math display">\[\mathbf{ y}= \mathbf{ f}_4\left(\mathbf{ f}_3\left(\mathbf{ f}_2\left(\mathbf{ f}_1\left(\mathbf{ x}\right)\right)\right)\right)\]</span></p>
<p>Mathematically, a deep Gaussian process can be seen as a composite <em>multivariate</em> function, <span class="math display">\[
  \mathbf{g}(\mathbf{ x})=\mathbf{ f}_5(\mathbf{ f}_4(\mathbf{ f}_3(\mathbf{ f}_2(\mathbf{ f}_1(\mathbf{ x}))))).
  \]</span> Or if we view it from the probabilistic perspective we can see that a deep Gaussian process is specifying a factorization of the joint density, the standard deep model takes the form of a Markov chain.</p>
<p><span class="math display">\[
  p(\mathbf{ y}|\mathbf{ x})= p(\mathbf{ y}|\mathbf{ f}_5)p(\mathbf{ f}_5|\mathbf{ f}_4)p(\mathbf{ f}_4|\mathbf{ f}_3)p(\mathbf{ f}_3|\mathbf{ f}_2)p(\mathbf{ f}_2|\mathbf{ f}_1)p(\mathbf{ f}_1|\mathbf{ x})
  \]</span></p>
<div class="figure">
<div id="deep-markov-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/deep-markov.svg" width="80%" style=" ">
</object>
</div>
<div id="deep-markov-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="deep-markov-caption" class="caption-frame">
<p>Figure: Probabilistically the deep Gaussian process can be represented as a Markov chain. Indeed they can even be analyzed in this way <span class="citation" data-cites="Dunlop:deep2017">(Dunlop et al., n.d.)</span>.</p>
</div>
</div>
<div class="figure">
<div id="deep-markov-vertical-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/deep-markov-vertical.svg" width="7%" style=" ">
</object>
</div>
<div id="deep-markov-vertical-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov-vertical&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="deep-markov-vertical-caption" class="caption-frame">
<p>Figure: More usually deep probabilistic models are written vertically rather than horizontally as in the Markov chain.</p>
</div>
</div>
<h2 id="why-composition">Why Composition?</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/process-composition.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/process-composition.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>If the result of composing many functions together is simply another function, then why do we bother? The key point is that we can change the class of functions we are modeling by composing in this manner. A Gaussian process is specifying a prior over functions, and one with a number of elegant properties. For example, the derivative process (if it exists) of a Gaussian process is also Gaussian distributed. That makes it easy to assimilate, for example, derivative observations. But that also might raise some alarm bells. That implies that the <em>marginal derivative distribution</em> is also Gaussian distributed. If that’s the case, then it means that functions which occasionally exhibit very large derivatives are hard to model with a Gaussian process. For example, a function with jumps in.</p>
<p>A one off discontinuity is easy to model with a Gaussian process, or even multiple discontinuities. They can be introduced in the mean function, or independence can be forced between two covariance functions that apply in different areas of the input space. But in these cases we will need to specify the number of discontinuities and where they occur. In otherwords we need to <em>parameterise</em> the discontinuities. If we do not know the number of discontinuities and don’t wish to specify where they occur, i.e. if we want a non-parametric representation of discontinuities, then the standard Gaussian process doesn’t help.</p>
<h2 id="stochastic-process-composition-1">Stochastic Process Composition</h2>
<p>The deep Gaussian process leads to <em>non-Gaussian</em> models, and non-Gaussian characteristics in the covariance function. In effect, what we are proposing is that we change the properties of the functions we are considering by <em>composing stochastic processes</em>. This is an approach to creating new stochastic processes from well known processes.</p>
<p>Additionally, we are not constrained to the formalism of the chain. For example, we can easily add single nodes emerging from some point in the depth of the chain. This allows us to combine the benefits of the graphical modelling formalism, but with a powerful framework for relating one set of variables to another, that of Gaussian processes</p>
<div class="figure">
<div id="deep-markov-vertical-side-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/deep-markov-vertical-side.svg" width="15%" style=" ">
</object>
</div>
<div id="deep-markov-vertical-side-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov-vertical-side&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="deep-markov-vertical-side-caption" class="caption-frame">
<p>Figure: More generally we aren’t constrained by the Markov chain. We can design structures that respect our belief about the underlying conditional dependencies. Here we are adding a side note from the chain.</p>
</div>
</div>
<h2 id="gpy-a-gaussian-process-framework-in-python">GPy: A Gaussian Process Framework in Python</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/gpy-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/gpy-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Gaussian processes are a flexible tool for non-parametric analysis with uncertainty. The GPy software was started in Sheffield to provide a easy to use interface to GPs. One which allowed the user to focus on the modelling rather than the mathematics.</p>
<div class="figure">
<div id="gpy-software-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//gp/gpy.png" width="70%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="gpy-software-magnify" class="magnify" onclick="magnifyFigure(&#39;gpy-software&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="gpy-software-caption" class="caption-frame">
<p>Figure: GPy is a BSD licensed software code base for implementing Gaussian process models in Python. It is designed for teaching and modelling. We welcome contributions which can be made through the GitHub repository <a href="https://github.com/SheffieldML/GPy" class="uri">https://github.com/SheffieldML/GPy</a></p>
</div>
</div>
<p>GPy is a BSD licensed software code base for implementing Gaussian process models in python. This allows GPs to be combined with a wide variety of software libraries.</p>
<p>The software itself is available on <a href="https://github.com/SheffieldML/GPy">GitHub</a> and the team welcomes contributions.</p>
<p>The aim for GPy is to be a probabilistic-style programming language, i.e., you specify the model rather than the algorithm. As well as a large range of covariance functions the software allows for non-Gaussian likelihoods, multivariate outputs, dimensionality reduction and approximations for larger data sets.</p>
<p>The documentation for GPy can be found <a href="https://gpy.readthedocs.io/en/latest/">here</a>.</p>
<p>This notebook depends on PyDeepGP. This library can be installed via pip.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install <span class="op">--</span>upgrade git<span class="op">+</span>https:<span class="op">//</span>github.com<span class="op">/</span>SheffieldML<span class="op">/</span>PyDeepGP.git</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Late bind setup methods to DeepGP object</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai.deepgp_tutorial <span class="im">import</span> initialize</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai.deepgp_tutorial <span class="im">import</span> staged_optimize</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai.deepgp_tutorial <span class="im">import</span> posterior_sample</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai.deepgp_tutorial <span class="im">import</span> visualize</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai.deepgp_tutorial <span class="im">import</span> visualize_pinball</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> deepgp</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>deepgp.DeepGP.initialize<span class="op">=</span>initialize</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>deepgp.DeepGP.staged_optimize<span class="op">=</span>staged_optimize</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>deepgp.DeepGP.posterior_sample<span class="op">=</span>posterior_sample</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>deepgp.DeepGP.visualize<span class="op">=</span>visualize</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>deepgp.DeepGP.visualize_pinball<span class="op">=</span>visualize_pinball</span></code></pre></div>
<h2 id="olympic-marathon-data">Olympic Marathon Data</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_datasets/includes/olympic-marathon-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_datasets/includes/olympic-marathon-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<table>
<tr>
<td width="70%">
<ul>
<li>Gold medal times for Olympic Marathon since 1896.</li>
<li>Marathons before 1924 didn’t have a standardized distance.</li>
<li>Present results using pace per km.</li>
<li>In 1904 Marathon was badly organized leading to very slow times.</li>
</ul>
</td>
<td width="30%">
<div class="centered centered" style="">
<img class="" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//Stephen_Kiprotich.jpg" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
<small>Image from Wikimedia Commons <a href="http://bit.ly/16kMKHQ" class="uri">http://bit.ly/16kMKHQ</a></small>
</td>
</tr>
</table>
<p>The first thing we will do is load a standard data set for regression modelling. The data consists of the pace of Olympic Gold Medal Marathon winners for the Olympics from 1896 to present. Let’s load in the data and plot.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pods</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pods.datasets.olympic_marathon_men()</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>offset <span class="op">=</span> y.mean()</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>scale <span class="op">=</span> np.sqrt(y.var())</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>yhat <span class="op">=</span> (y <span class="op">-</span> offset)<span class="op">/</span>scale</span></code></pre></div>
<div class="figure">
<div id="olympic-marathon-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//datasets/olympic-marathon.svg" width="80%" style=" ">
</object>
</div>
<div id="olympic-marathon-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-caption" class="caption-frame">
<p>Figure: Olympic marathon pace times since 1896.</p>
</div>
</div>
<p>Things to notice about the data include the outlier in 1904, in that year the Olympics was in St Louis, USA. Organizational problems and challenges with dust kicked up by the cars following the race meant that participants got lost, and only very few participants completed. More recent years see more consistently quick marathons.</p>
<h2 id="alan-turing">Alan Turing</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/alan-turing-marathon.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/alan-turing-marathon.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<div class="figure">
<div id="turing-run-times-figure" class="figure-frame">
<table>
<tr>
<td width="50%">
<div class="centered" style="">
<img class="" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//turing-times.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
<td width="50%">
<div class="centered centered" style="">
<img class="" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//turing-run.jpg" width="50%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="turing-run-times-magnify" class="magnify" onclick="magnifyFigure(&#39;turing-run-times&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="turing-run-times-caption" class="caption-frame">
<p>Figure: Alan Turing, in 1946 he was only 11 minutes slower than the winner of the 1948 games. Would he have won a hypothetical games held in 1946? Source: <a href="http://www.turing.org.uk/scrapbook/run.html" target="_blank">Alan Turing Internet Scrapbook</a>.</p>
</div>
</div>
<p>If we had to summarise the objectives of machine learning in one word, a very good candidate for that word would be <em>generalization</em>. What is generalization? From a human perspective it might be summarised as the ability to take lessons learned in one domain and apply them to another domain. If we accept the definition given in the first session for machine learning, <span class="math display">\[
\text{data} + \text{model} \stackrel{\text{compute}}{\rightarrow} \text{prediction}
\]</span> then we see that without a model we can’t generalise: we only have data. Data is fine for answering very specific questions, like “Who won the Olympic Marathon in 2012?” because we have that answer stored, however, we are not given the answer to many other questions. For example, Alan Turing was a formidable marathon runner, in 1946 he ran a time 2 hours 46 minutes (just under four minutes per kilometer, faster than I and most of the other <a href="http://www.parkrun.org.uk/sheffieldhallam/">Endcliffe Park Run</a> runners can do 5 km). What is the probability he would have won an Olympics if one had been held in 1946?</p>
<p>To answer this question we need to generalize, but before we formalize the concept of generalization let’s introduce some formal representation of what it means to generalize in machine learning.</p>
<h2 id="gaussian-process-fit">Gaussian Process Fit</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/olympic-marathon-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/olympic-marathon-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Our first objective will be to perform a Gaussian process fit to the data, we’ll do this using the <a href="https://github.com/SheffieldML/GPy">GPy software</a>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></span></code></pre></div>
<p>The first command sets up the model, then <code>m_full.optimize()</code> optimizes the parameters of the covariance function and the noise level of the model. Once the fit is complete, we’ll try creating some test points, and computing the output of the GP model in terms of the mean and standard deviation of the posterior functions between 1870 and 2030. We plot the mean function and the standard deviation at 200 locations. We can obtain the predictions using <code>y_mean, y_var = m_full.predict(xt)</code></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>xt <span class="op">=</span> np.linspace(<span class="dv">1870</span>,<span class="dv">2030</span>,<span class="dv">200</span>)[:,np.newaxis]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>yt_mean, yt_var <span class="op">=</span> m_full.predict(xt)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>yt_sd<span class="op">=</span>np.sqrt(yt_var)</span></code></pre></div>
<p>Now we plot the results using the helper function in <code>mlai.plot</code>.</p>
<div class="figure">
<div id="olympic-marathon-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//gp/olympic-marathon-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="olympic-marathon-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the Olympic Marathon data. The error bars are too large, perhaps due to the outlier from 1904.</p>
</div>
</div>
<h2 id="fit-quality">Fit Quality</h2>
<p>In the fit we see that the error bars (coming mainly from the noise variance) are quite large. This is likely due to the outlier point in 1904, ignoring that point we can see that a tighter fit is obtained. To see this make a version of the model, <code>m_clean</code>, where that point is removed.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>x_clean<span class="op">=</span>np.vstack((x[<span class="dv">0</span>:<span class="dv">2</span>, :], x[<span class="dv">3</span>:, :]))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>y_clean<span class="op">=</span>np.vstack((yhat[<span class="dv">0</span>:<span class="dv">2</span>, :], yhat[<span class="dv">3</span>:, :]))</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>m_clean <span class="op">=</span> GPy.models.GPRegression(x_clean,y_clean)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> m_clean.optimize()</span></code></pre></div>
<h2 id="deep-gp-fit">Deep GP Fit</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/olympic-marathon-deep-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/olympic-marathon-deep-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Let’s see if a deep Gaussian process can help here. We will construct a deep Gaussian process with one hidden layer (i.e. one Gaussian process feeding into another).</p>
<p>Build a Deep GP with an additional hidden layer (one dimensional) to fit the model.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> deepgp</span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>hidden <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> deepgp.DeepGP([y.shape[<span class="dv">1</span>],hidden,x.shape[<span class="dv">1</span>]],Y<span class="op">=</span>yhat, X<span class="op">=</span>x, inits<span class="op">=</span>[<span class="st">&#39;PCA&#39;</span>,<span class="st">&#39;PCA&#39;</span>], </span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>                  kernels<span class="op">=</span>[GPy.kern.RBF(hidden,ARD<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>                           GPy.kern.RBF(x.shape[<span class="dv">1</span>],ARD<span class="op">=</span><span class="va">True</span>)], <span class="co"># the kernels for each layer</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the initalization</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>m.initialize()</span></code></pre></div>
<p>Now optimize the model.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> layer <span class="kw">in</span> m.layers:</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>m.optimize(messages<span class="op">=</span><span class="va">True</span>,max_iters<span class="op">=</span><span class="dv">10000</span>)</span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>m.staged_optimize(messages<span class="op">=</span>(<span class="va">True</span>,<span class="va">True</span>,<span class="va">True</span>))</span></code></pre></div>
<h2 id="olympic-marathon-data-deep-gp">Olympic Marathon Data Deep GP</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/olympic-marathon-deep-gp.svg" width="100%" style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-deep-gp-caption" class="caption-frame">
<p>Figure: Deep GP fit to the Olympic marathon data. Error bars now change as the prediction evolves.</p>
</div>
</div>
<h2 id="olympic-marathon-data-deep-gp-1">Olympic Marathon Data Deep GP</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-samples-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/olympic-marathon-deep-gp-samples.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-samples&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-deep-gp-samples-caption" class="caption-frame">
<p>Figure: Point samples run through the deep Gaussian process show the distribution of output locations.</p>
</div>
</div>
<h2 id="fitted-gp-for-each-layer">Fitted GP for each layer</h2>
<p>Now we explore the GPs the model has used to fit each layer. First of all, we look at the hidden layer.</p>
<div class="figure">
<div id="olympic-marathon-deep-gp-layer-0-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/olympic-marathon-deep-gp-layer-0.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-layer-0-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-layer-0&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-deep-gp-layer-0-caption" class="caption-frame">
<p>Figure: The mapping from input to the latent layer is broadly, with some flattening as time goes on. Variance is high across the input range.</p>
</div>
</div>
<div class="figure">
<div id="olympic-marathon-deep-gp-layer-1-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/olympic-marathon-deep-gp-layer-1.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-layer-1-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-layer-1&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-deep-gp-layer-1-caption" class="caption-frame">
<p>Figure: The mapping from the latent layer to the output layer.</p>
</div>
</div>
<h2 id="olympic-marathon-pinball-plot">Olympic Marathon Pinball Plot</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-pinball-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//deepgp/olympic-marathon-deep-gp-pinball.svg" width="80%" style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-pinball&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-marathon-deep-gp-pinball-caption" class="caption-frame">
<p>Figure: A pinball plot shows the movement of the ‘ball’ as it passes through each layer of the Gaussian processes. Mean directions of movement are shown by lines. Shading gives one standard deviation of movement position. At each layer, the uncertainty is reset. The overal uncertainty is the cumulative uncertainty from all the layers. There is some grouping of later points towards the right in the first layer, which also injects a large amount of uncertainty. Due to flattening of the curve in the second layer towards the right the uncertainty is reduced in final output.</p>
</div>
</div>
<p>The pinball plot shows the flow of any input ball through the deep Gaussian process. In a pinball plot a series of vertical parallel lines would indicate a purely linear function. For the olypmic marathon data we can see the first layer begins to shift from input towards the right. Note it also does so with some uncertainty (indicated by the shaded backgrounds). The second layer has less uncertainty, but bunches the inputs more strongly to the right. This input layer of uncertainty, followed by a layer that pushes inputs to the right is what gives the heteroschedastic noise.</p>
<h2 id="deep-emulation">Deep Emulation</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/deep-emulation.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/deep-emulation.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<div class="figure">
<div id="ml-system-downstream-simulation0-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//simulation/ml-system-downstream-simulation000.svg" width="75%" style=" ">
</object>
</div>
<div id="ml-system-downstream-simulation0-magnify" class="magnify" onclick="magnifyFigure(&#39;ml-system-downstream-simulation0&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="ml-system-downstream-simulation0-caption" class="caption-frame">
<p>Figure: A potential path of models in the emulation of a simulation system.</p>
</div>
</div>
<p>As a solution we can use of <em>emulators</em>. When constructing an ML system, software engineers, ML engineers, economists and operations researchers are explicitly defining relationships between variables of interest in the system. That implicitly defines a joint distribution, <span class="math inline">\(p(\mathbf{ y}^*, \mathbf{ y})\)</span>. In a decomposable system any sub-component may be defined as <span class="math inline">\(p(\mathbf{ y}_\mathbf{i}|\mathbf{ y}_\mathbf{j})\)</span> where <span class="math inline">\(\mathbf{ y}_\mathbf{i}\)</span> and <span class="math inline">\(\mathbf{ y}_\mathbf{j}\)</span> represent sub-sets of the full set of variables <span class="math inline">\(\left\{\mathbf{ y}^*, \mathbf{ y}\right\}\)</span>. In those cases where the relationship is deterministic, the probability density would collapse to a vector-valued deterministic function, <span class="math inline">\(\mathbf{ f}_\mathbf{i}\left(\mathbf{ y}_\mathbf{j}\right)\)</span>.</p>
<p>Inter-variable relationships could be defined by, for example a neural network (machine learning), an integer program (operational research), or a simulation (supply chain). This makes probabilistic inference in this joint density for real world systems is either very hard or impossible.</p>
<p>Emulation is a form of meta-modelling: we construct a model of the model. We can define the joint density of an emulator as <span class="math inline">\(s(\mathbf{ y}*, \mathbf{ y})\)</span>, but if this probability density is to be an accurate representation of our system, it is likely to be prohibitively complex. Current practice is to design an emulator to deal with a specific question. This is done by fitting an ML model to a simulation from the the appropriate conditional distribution, <span class="math inline">\(p(\mathbf{ y}_\mathbf{i}|\mathbf{ y}_\mathbf{j})\)</span>, which is intractable. The emulator provides an approximated answer of the form <span class="math inline">\(s(\mathbf{ y}_\mathbf{i}|\mathbf{ y}_\mathbf{j})\)</span>. Critically, an emulator should incorporate its uncertainty about its approximation. So the emulator answer will be less certain than direct access to the conditional <span class="math inline">\(p(\mathbf{ y}_i|\mathbf{ y}_j)\)</span>, but it may be sufficiently confident to act upon. Careful design of emulators to answer a given question leads to efficient diagnostics and understanding of the system. But in a complex interacting system an exponentially increasing number of questions can be asked. This calls for a system of automated construction of emulators which selects the right structure and redeploys the emulator as necessary. Rapid redeployment of emulators could exploit pre-existing emulators through <em>transfer learning</em>.</p>
<p>Automatically deploying these families of emulators for full system understanding is highly ambitious. It requires advances in engineering infrastructure, emulation, and Bayesian optimization. However, the intermediate steps of developing this architecture also allow for automated monitoring of system accuracy and fairness. This facilitates AutoML on a component-wise basis which we can see as a simple implementation of AutoAI. The proposal is structured so that despite its technical ambition there is a smooth ramp of benefits to be derived across the program of work.</p>
<p>In Applied Mathematics, the field studying these techniques is known as <em>uncertainty quantification</em>. The new challenge is the automation of emulator creation on demand to answer questions of interest and facilitate the system design, i.e. AutoAI through BSO.</p>
<p>At design stage, any AI task could be decomposed in multiple ways. Bayesian system optimization will assist both in determining the large-scale system design through exploring different decompositions and in refinement of the deployed system.</p>
<p>So far, most work on emulators has focused on emulating a single component. Automated deployment and maintenance of ML systems requires networks of emulators that can be deployed and redeployed on demand depending on the question of interest. Therefore, the technical innovations we require are in the mathematical composition of emulator models <span class="citation" data-cites="Damianou:deepgp13 Pedikaris:nonlinear17">(Damianou and Lawrence, 2013; Paris Perdikaris et al., 2017)</span>. Different chains of emulators will need to be rapidly composed to make predictions of downstream performance. This requires rapid retraining of emulators and <em>propagation of uncertainty</em> through the emulation pipeline a process we call <em>deep emulation</em>.</p>
<p>This structural learning allows us to associate data with the relevant layer of the model, rather than merely on the leaf nodes of the output model. When deploying the deep Gaussian process as an emulator, this allows for the possibility of learning the structure of the different component parts of the underlying system. This should aid the user in determining the ideal system decomposition.</p>
<div class="figure">
<div id="ml-system-downstream-simulation1-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//simulation/ml-system-downstream-simulation001.svg" width="75%" style=" ">
</object>
</div>
<div id="ml-system-downstream-simulation1-magnify" class="magnify" onclick="magnifyFigure(&#39;ml-system-downstream-simulation1&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="ml-system-downstream-simulation1-caption" class="caption-frame">
<p>Figure: A potential path of models in a machine learning system.</p>
</div>
</div>
<div class="figure">
<div id="ml-system-downstream-simulation2-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//simulation/ml-system-downstream-simulation002.svg" width="75%" style=" ">
</object>
</div>
<div id="ml-system-downstream-simulation2-magnify" class="magnify" onclick="magnifyFigure(&#39;ml-system-downstream-simulation2&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="ml-system-downstream-simulation2-caption" class="caption-frame">
<p>Figure: A potential path of models in the emulation of a simulation system.</p>
</div>
</div>
<div class="figure">
<div id="ml-system-downstream-simulation3-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//simulation/ml-system-downstream-simulation003.svg" width="75%" style=" ">
</object>
</div>
<div id="ml-system-downstream-simulation3-magnify" class="magnify" onclick="magnifyFigure(&#39;ml-system-downstream-simulation3&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="ml-system-downstream-simulation3-caption" class="caption-frame">
<p>Figure: A potential path of models in the emulation of a simulation system.</p>
</div>
</div>
<h2 id="brief-reflection">Brief Reflection</h2>
<p>In this module, we have been introducing various aspects of surrogate modelling. We’ve already seen in the sensitivity analysis section, how we used experimental design to make our acquisition of data for the Catapult simulator more efficient. To round of the taught session of the course, we’ll also combine ideas from Bayesian optimization, with an emulator built through experimental design.</p>
<p>The task is a classic example from reinforcement learning, known as the ‘Mountain Car.’ The idea is to drive an underpowered car up a hill. The car doesn’t have the ability to accelerate hard enough, but it can build momentum by oscillating up and down a hill to get to the target.</p>
<p>We provide some wrappers of the OpenAI Gym version of the mountain car simulation in a python file. We will use this example to combine various ideas from surrogate modelling to solve the problem.</p>
<div class="figure">
<div id="mountain-car-emulation-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mountain-car-emulation.svg" width="80%" style=" ">
</object>
</div>
<div id="mountain-car-emulation-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-emulation&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mountain-car-emulation-caption" class="caption-frame">
<p>Figure: The mountain car example contains a simulation of a car’s dynamics within the wider simulation of the mountain. The simulation of the car is called as a subroutine many times by the wider simulation of the mountain. We can choose to build a surrogate model of the car, and work with a modified mountain simulation where the emulator is called instead of the car’s simulation directly.</p>
</div>
</div>
<h2 id="mountain-car-simulator">Mountain Car Simulator</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-simulation.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-simulation.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>To illustrate the above mentioned concepts we use the <a href="https://github.com/openai/gym/wiki/MountainCarContinuous-v0">mountain car simulator</a>. This simulator is widely used in machine learning to test reinforcement learning algorithms. The goal is to define a control policy on a car whose objective is to climb a mountain. Graphically, the problem looks as follows:</p>
<div class="figure">
<div id="mountain-car-figure" class="figure-frame">
<div class="centered" style="">
<img class="negate" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mountaincar.png" width="60%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="mountain-car-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mountain-car-caption" class="caption-frame">
<p>Figure: The mountain car simulation from the Open AI gym.</p>
</div>
</div>
<p>The goal is to define a sequence of actions (push the car right or left with certain intensity) to make the car reach the flag after a number <span class="math inline">\(T\)</span> of time steps.</p>
<p>At each time step <span class="math inline">\(t\)</span>, the car is characterized by a vector <span class="math inline">\(\mathbf{ x}_{t} = (p_t,v_t)\)</span> of states which are respectively the the position and velocity of the car at time <span class="math inline">\(t\)</span>. For a sequence of states (an episode), the dynamics of the car is given by</p>
<p><span class="math display">\[
\mathbf{ x}_{t+1} = f(\mathbf{ x}_{t},\textbf{u}_{t})
\]</span></p>
<p>where <span class="math inline">\(\textbf{u}_{t}\)</span> is the value of an action force, which in this example corresponds to push car to the left (negative value) or to the right (positive value). The actions across a full episode are represented in a policy <span class="math inline">\(\textbf{u}_{t} = \pi(\mathbf{ x}_{t},\theta)\)</span> that acts according to the current state of the car and some parameters <span class="math inline">\(\theta\)</span>. In the following examples we will assume that the policy is linear which allows us to write <span class="math inline">\(\pi(\mathbf{ x}_{t},\theta)\)</span> as</p>
<h2 id="mountain-car-set-up">Mountain Car Set Up</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-setup.py" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-setup.py', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>To run the mountain car example we need to install a python file that we’ll download.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>urllib.request.urlretrieve(<span class="st">&#39;https://raw.githubusercontent.com/lawrennd/talks/gh-pages/mountain_car.py&#39;</span>,<span class="st">&#39;mountain_car.py&#39;</span>)</span></code></pre></div>
<p>And to render the environment, the <code>pyglet</code> library.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install pyglet</span></code></pre></div>
<p><span class="math display">\[
\pi(\mathbf{ x},\theta)= \theta_0 + \theta_p p + \theta_vv.
\]</span> For <span class="math inline">\(t=1,\dots,T\)</span> now given some initial state <span class="math inline">\(\mathbf{ x}_{0}\)</span> and some some values of each <span class="math inline">\(\textbf{u}_{t}\)</span>, we can <strong>simulate</strong> the full dynamics of the car for a full episode using <a href="https://gym.openai.com/envs/">Gym</a>. The values of <span class="math inline">\(\textbf{u}_{t}\)</span> are fully determined by the parameters of the linear controller.</p>
<p>After each episode of length <span class="math inline">\(T\)</span> is complete, a reward function <span class="math inline">\(R_{T}(\theta)\)</span> is computed. In the mountain car example, the reward is computed as 100 for reaching the target of the hill on the right hand side, minus the squared sum of actions (a real negative to push to the left and a real positive to push to the right) from start to goal. Note that our reward depends on <span class="math inline">\(\theta\)</span> as we make it dependent on the parameters of the linear controller.</p>
<h2 id="emulate-the-mountain-car">Emulate the Mountain Car</h2>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install gym</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gym</span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</span></code></pre></div>
<p>Our goal in this section is to find the parameters <span class="math inline">\(\theta\)</span> of the linear controller such that</p>
<p><span class="math display">\[
\theta^* = arg \max_{\theta} R_T(\theta).
\]</span></p>
<p>In this section, we directly use Bayesian optimization to solve this problem. We will use <a href="https://emukit.github.io">EmuKit</a> so we first define the objective function.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mountain_car <span class="im">as</span> mc</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<p>For each set of parameter values of the linear controller we can run an episode of the simulator (that we fix to have a horizon of <span class="math inline">\(T=500\)</span>) to generate the reward. Using as input the parameters of the controller and as outputs the rewards we can build a Gaussian process emulator of the reward.</p>
<p>We start defining the input space, which is three-dimensional:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core <span class="im">import</span> ContinuousParameter, ParameterSpace</span></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>position_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>velocity_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>]</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>constant_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>space <span class="op">=</span> ParameterSpace(</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>          [ContinuousParameter(<span class="st">&#39;position_parameter&#39;</span>, <span class="op">*</span>position_domain), </span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;velocity_parameter&#39;</span>, <span class="op">*</span>velocity_domain),</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;constant&#39;</span>, <span class="op">*</span>constant_domain)])</span></code></pre></div>
<p>To initalize the model we start sampling some initial points for the linear controller randomly.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core.initial_designs <span class="im">import</span> RandomDesign</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>design <span class="op">=</span> RandomDesign(space)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>n_initial_points <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>initial_design <span class="op">=</span> design.get_samples(n_initial_points)</span></code></pre></div>
<p>Now run the simulation 25 times across our initial design.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> target_function(initial_design)</span></code></pre></div>
<p>Before we start any optimization, lets have a look to the behaviour of the car with the first of these initial points that we have selected randomly.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<p>This won’t render in Google <code>colab</code>, but should work in a regular Jupyter notebook if <code>pyglet</code> is installed. Details on rendering in <code>colab</code> are given in answer to this stackoverflow question <a href="https://stackoverflow.com/questions/50107530/how-to-render-openai-gym-in-google-colab" class="uri">https://stackoverflow.com/questions/50107530/how-to-render-openai-gym-in-google-colab</a>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>random_controller <span class="op">=</span> initial_design[<span class="dv">0</span>,:]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(random_controller), render<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Random linear controller&#39;</span>)</span></code></pre></div>
<div class="figure">
<div id="mountain-car-random-figure" class="figure-frame">
<iframe src="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mountain-car-random.html" width="600" height="450" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-random-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-random&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mountain-car-random-caption" class="caption-frame">
<p>Figure: Random linear controller for the Mountain car. It fails to move the car to the top of the mountain.</p>
</div>
</div>
<p>As we can see the random linear controller does not manage to push the car to the top of the mountain. Now, let’s optimize the regret using Bayesian optimization and the emulator for the reward. We try 50 new parameters chosen by the expected improvement acquisition function.</p>
<p>First, we initizialize a Gaussian process emulator.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">3</span>)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>model_gpy <span class="op">=</span> GPy.models.GPRegression(initial_design, y, kern, noise_var<span class="op">=</span><span class="fl">1e-10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.model_wrappers.gpy_model_wrappers <span class="im">import</span> GPyModelWrapper</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>model_emukit <span class="op">=</span> GPyModelWrapper(model_gpy, n_restarts<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>model_emukit.optimize()</span></code></pre></div>
<p>In Bayesian optimization an acquisition function is used to balance exploration and exploitation to evaluate new locations close to the optimum of the objective. In this notebook we select the expected improvement (EI). For further details have a look at the review paper of <span class="citation" data-cites="Shahriari-human16">Shahriari et al. (2016)</span>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.bayesian_optimization.acquisitions <span class="im">import</span> ExpectedImprovement</span></code></pre></div>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>acquisition <span class="op">=</span> ExpectedImprovement(model_emukit)</span></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.bayesian_optimization.loops.bayesian_optimization_loop <span class="im">import</span> BayesianOptimizationLoop</span></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>bo <span class="op">=</span> BayesianOptimizationLoop(space, model_emukit, acquisition<span class="op">=</span>acquisition)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>bo.run_loop(target_function, <span class="dv">50</span>)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>results<span class="op">=</span> bo.get_results()</span></code></pre></div>
<p>Now we visualize the result for the best controller that we have found with Bayesian optimization.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(results.minimum_location), render<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller after 50 iterations of Bayesian optimization&#39;</span>)</span></code></pre></div>
<div class="figure">
<div id="mountain-car-similated-bayes-opt-figure" class="figure-frame">
<iframe src="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mountain-car-simulated.html" width="600" height="450" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-similated-bayes-opt-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-similated-bayes-opt&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mountain-car-similated-bayes-opt-caption" class="caption-frame">
<p>Figure: Mountain car simulator trained using Bayesian optimization and the simulator of the dynamics. Fifty iterations of Bayesian optimization are used to optimize the controler.</p>
</div>
</div>
<p>The car can now make it to the top of the mountain! Emulating the reward function and using expected improvement acquisition helped us to find a linear controller that solves the problem.</p>
<h2 id="data-efficient-emulation">Data Efficient Emulation</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-data-efficient.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-data-efficient.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In the previous section we solved the mountain car problem by directly emulating the reward but no considerations about the dynamics <span class="math display">\[
\mathbf{ x}_{t+1} =g(\mathbf{ x}_{t},\textbf{u}_{t})
\]</span> of the system were made.</p>
<p>We ran the simulator 25 times in the initial design, and 50 times in our Bayesian optimization loop. That required us to call the dynamics simulation <span class="math inline">\(500\times 75 =37,500\)</span> times, because each simulation of the car used 500 steps. In this section we will show how it is possible to reduce this number by building an emulator for <span class="math inline">\(g(\cdot)\)</span> that can later be used to directly optimize the control.</p>
<p>The inputs of the model for the dynamics are the velocity, the position and the value of the control so create this space accordingly.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gym</span></code></pre></div>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core <span class="im">import</span> ContinuousParameter, ParameterSpace</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>position_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="fl">0.6</span>]</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>velocity_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">0.07</span>, <span class="op">+</span><span class="fl">0.07</span>]</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>action_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>space_dynamics <span class="op">=</span> ParameterSpace(</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>          [ContinuousParameter(<span class="st">&#39;position_dynamics_parameter&#39;</span>, <span class="op">*</span>position_dynamics_domain), </span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;velocity_dynamics_parameter&#39;</span>, <span class="op">*</span>velocity_dynamics_domain),</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;action_dynamics_parameter&#39;</span>, <span class="op">*</span>action_dynamics_domain)])</span></code></pre></div>
<p>Next, we sample some input parameters and use the simulator to compute the outputs. Note that in this case we are not running the full episodes, we are just using the simulator to compute <span class="math inline">\(\mathbf{ x}_{t+1}\)</span> given <span class="math inline">\(\mathbf{ x}_{t}\)</span> and <span class="math inline">\(\textbf{u}_{t}\)</span>.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core.initial_designs <span class="im">import</span> RandomDesign</span></code></pre></div>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>design_dynamics <span class="op">=</span> RandomDesign(space_dynamics)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>n_initial_points <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>initial_design_dynamics <span class="op">=</span> design_dynamics.get_samples(n_initial_points)</span></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mountain_car <span class="im">as</span> mc</span></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">### --- Simulation of the (normalized) outputs</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>y_dynamics <span class="op">=</span> np.zeros((initial_design_dynamics.shape[<span class="dv">0</span>], <span class="dv">2</span>))</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(initial_design_dynamics.shape[<span class="dv">0</span>]):</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    y_dynamics[i, :] <span class="op">=</span> mc.simulation(initial_design_dynamics[i, :])</span></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalize the data from the simulation</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>y_dynamics_normalisation <span class="op">=</span> np.std(y_dynamics, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>y_dynamics_normalised <span class="op">=</span> y_dynamics<span class="op">/</span>y_dynamics_normalisation</span></code></pre></div>
<p>The outputs are the velocity and the position. Our model will capture the change in position and velocity on time. That is, we will model</p>
<p><span class="math display">\[
\Delta v_{t+1} = v_{t+1} - v_{t}
\]</span></p>
<p><span class="math display">\[
\Delta x_{t+1} = p_{t+1} - p_{t}
\]</span></p>
<p>with Gaussian processes with prior mean <span class="math inline">\(v_{t}\)</span> and <span class="math inline">\(p_{t}\)</span> respectively. As a covariance function, we use <code>Matern52</code>. We need therefore two models to capture the full dynamics of the system.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span></code></pre></div>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>kern_position <span class="op">=</span> GPy.kern.Matern52(<span class="dv">3</span>)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>position_model_gpy <span class="op">=</span> GPy.models.GPRegression(initial_design_dynamics, y_dynamics[:, <span class="dv">0</span>:<span class="dv">1</span>], kern_position, noise_var<span class="op">=</span><span class="fl">1e-10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>kern_velocity <span class="op">=</span> GPy.kern.Matern52(<span class="dv">3</span>)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>velocity_model_gpy <span class="op">=</span> GPy.models.GPRegression(initial_design_dynamics, y_dynamics[:, <span class="dv">1</span>:<span class="dv">2</span>], kern_velocity, noise_var<span class="op">=</span><span class="fl">1e-10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.model_wrappers.gpy_model_wrappers <span class="im">import</span> GPyModelWrapper</span></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>position_model_emukit <span class="op">=</span> GPyModelWrapper(position_model_gpy, n_restarts<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>velocity_model_emukit <span class="op">=</span> GPyModelWrapper(velocity_model_gpy, n_restarts<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div>
<p>In general, we might use much smarter strategies to design our emulation of the simulator. For example, we could use the variance of the predictive distributions of the models to collect points using uncertainty sampling, which will give us a better coverage of the space. For simplicity, we move ahead with the 500 randomly selected points.</p>
<p>Now that we have a data set, we can update the emulators for the location and the velocity.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>position_model_emukit.optimize()</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>velocity_model_emukit.optimize()</span></code></pre></div>
<p>We can now have a look to how the emulator and the simulator match. First, we show a contour plot of the car acceleration for each pair of can position and velocity. You can use the bar bellow to play with the values of the controller to compare the emulator and the simulator.</p>
<p>We can see how the emulator is doing a fairly good job approximating the simulator. On the edges, however, it struggles to captures the dynamics of the simulator.</p>
<p>Given some input parameters of the linear controlling, how do the dynamics of the emulator and simulator match? In the following figure we show the position and velocity of the car for the 500 time-steps of an episode in which the parameters of the linear controller have been fixed beforehand. The value of the input control is also shown.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># change the values of the linear controller to observe the trajectories.</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>controller_gains <span class="op">=</span> np.atleast_2d([<span class="dv">0</span>, <span class="fl">.6</span>, <span class="dv">1</span>])  </span></code></pre></div>
<div class="figure">
<div id="emu-sim-comparison-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/emu-sim-comparison.svg" width="80%" style=" ">
</object>
</div>
<div id="emu-sim-comparison-magnify" class="magnify" onclick="magnifyFigure(&#39;emu-sim-comparison&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="emu-sim-comparison-caption" class="caption-frame">
<p>Figure: Comparison between the mountain car simulator and the emulator.</p>
</div>
</div>
<p>We now make explicit use of the emulator, using it to replace the simulator and optimize the linear controller. Note that in this optimization, we don’t need to query the simulator anymore as we can reproduce the full dynamics of an episode using the emulator. For illustrative purposes, in this example we fix the initial location of the car.</p>
<p>We define the objective reward function in terms of the simulator.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">### --- Optimize control parameters with emulator</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>car_initial_location <span class="op">=</span> np.asarray([<span class="op">-</span><span class="fl">0.58912799</span>, <span class="dv">0</span>])</span></code></pre></div>
<p>And as before, we use Bayesian optimization to find the best possible linear controller.</p>
<p>The design space is the three continuous variables that make up the linear controller.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>position_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>velocity_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>]</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>constant_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>space <span class="op">=</span> ParameterSpace(</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>          [ContinuousParameter(<span class="st">&#39;position_parameter&#39;</span>, <span class="op">*</span>position_domain), </span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;velocity_parameter&#39;</span>, <span class="op">*</span>velocity_domain),</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;constant&#39;</span>, <span class="op">*</span>constant_domain)])</span></code></pre></div>
<!--```{.python}

```{space= [{'name':'linear_1', 'type':'continuous', 'domain':(-1/1.2, +1)},
        {'name':'linear_2', 'type':'continuous', 'domain':(-1/0.07, +1/0.07)},
        {'name':'constant', 'type':'continuous', 'domain':(-1, +1)}]-->
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core.initial_designs <span class="im">import</span> RandomDesign</span></code></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>design <span class="op">=</span> RandomDesign(space)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>n_initial_points <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>initial_design <span class="op">=</span> design.get_samples(n_initial_points)</span></code></pre></div>
<p>Now run the simulation 25 times across our initial design.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> target_function_emulator(initial_design)</span></code></pre></div>
<p>Now we set up the surrogate model for the Bayesian optimization loop.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span></code></pre></div>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">3</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>model_dynamics_emulated_gpy <span class="op">=</span> GPy.models.GPRegression(initial_design, y, kern, noise_var<span class="op">=</span><span class="fl">1e-10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.model_wrappers.gpy_model_wrappers <span class="im">import</span> GPyModelWrapper</span></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>model_dynamics_emulated_emukit <span class="op">=</span> GPyModelWrapper(model_dynamics_emulated_gpy, n_restarts<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>model_dynamics_emulated_emukit.optimize()</span></code></pre></div>
<p>We set the acquisition function to be expected improvement.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.bayesian_optimization.acquisitions <span class="im">import</span> ExpectedImprovement</span></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>acquisition <span class="op">=</span> ExpectedImprovement(model_emukit)</span></code></pre></div>
<p>And we set up the main loop for the Bayesian optimization.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.bayesian_optimization.loops.bayesian_optimization_loop <span class="im">import</span> BayesianOptimizationLoop</span></code></pre></div>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>bo <span class="op">=</span> BayesianOptimizationLoop(space, model_dynamics_emulated_emukit, acquisition<span class="op">=</span>acquisition)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>bo.run_loop(target_function_emulator, <span class="dv">50</span>)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> bo.get_results()</span></code></pre></div>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(results.minimum_location), render<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller using the emulator of the dynamics&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</span></code></pre></div>
<div class="figure">
<div id="mountain-car-emulated-figure" class="figure-frame">
<iframe src="https://mlatcl.github.io/mlphysical/./slides/diagrams//uq/mountain-car-emulated.html" width="600" height="450" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-emulated-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-emulated&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="mountain-car-emulated-caption" class="caption-frame">
<p>Figure: Mountain car controller learnt through emulation. Here 500 calls to the simulator are used to fit the controller rather than 37,500 calls to the simulator required in the standard learning.</p>
</div>
</div>
<p>And the problem is again solved, but in this case, we have replaced the simulator of the car dynamics by a Gaussian process emulator that we learned by calling the dynamics simulator only 500 times. Compared to the 37,500 calls that we needed when applying Bayesian optimization directly on the simulator this is a significant improvement. Of course, in practice the car dynamics are very simple for this example.</p>
<h2 id="mountain-car-multi-fidelity-emulation">Mountain Car: Multi-Fidelity Emulation</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-multi-fidelity-introduction.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-multi-fidelity-introduction.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In some scenarios we have simulators of the same environment that have different fidelities, that is that reflect with different level of accuracy the dynamics of the real world. Running simulations of the different fidelities also have a different cost: high-fidelity simulations are typically more expensive the low-fidelity. If we have access to these simulators, we can combine high and low-fidelity simulations under the same model.</p>
<p>So, let’s assume that we have two simulators of the mountain car dynamics, one of high fidelity (the one we have used) and another one of low fidelity. The traditional approach to this form of multi-fidelity emulation is to assume that <span class="math display">\[
f_i\left(\mathbf{ x}\right) = \rho f_{i-1}\left(\mathbf{ x}\right) + \delta_i\left(\mathbf{ x}\right),
\]</span> where <span class="math inline">\(f_{i-1}\left(\mathbf{ x}\right)\)</span> is a low-fidelity simulation of the problem of interest and <span class="math inline">\(f_i\left(\mathbf{ x}\right)\)</span> is a higher fidelity simulation. The function <span class="math inline">\(\delta_i\left(\mathbf{ x}\right)\)</span> represents the difference between the lower and higher fidelity simulation, which is considered additive. The additive form of this covariance means that if <span class="math inline">\(f_{0}\left(\mathbf{ x}\right)\)</span> and <span class="math inline">\(\left\{\delta_i\left(\mathbf{ x}\right)\right\}_{i=1}^m\)</span> are all Gaussian processes, then the process over all fidelities of simulation will be a joint Gaussian process.</p>
<p>But with deep Gaussian processes we can consider the form <span class="math display">\[
f_i\left(\mathbf{ x}\right) = g_{i}\left(f_{i-1}\left(\mathbf{ x}\right)\right) + \delta_i\left(\mathbf{ x}\right),
\]</span> where the low fidelity representation is nonlinearly transformed by <span class="math inline">\(g(\cdot)\)</span> before use in the process. This is the approach taken in <span class="citation" data-cites="Perdikaris:multifidelity17">P. Perdikaris et al. (2017)</span>. But once we accept that these models can be composed, a highly flexible framework can emerge. A key point is that the data enters the model at different levels and represents different aspects. For example, these correspond to the two fidelities of the mountain car simulator.</p>
<p>We start by sampling both at 250 random input locations.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gym</span></code></pre></div>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> emukit.core <span class="im">import</span> ContinuousParameter, ParameterSpace</span></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>position_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="fl">0.6</span>]</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>velocity_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="fl">0.07</span>, <span class="op">+</span><span class="fl">0.07</span>]</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>action_dynamics_domain <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>space_dynamics <span class="op">=</span> ParameterSpace(</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>          [ContinuousParameter(<span class="st">&#39;position_dynamics_parameter&#39;</span>, <span class="op">*</span>position_dynamics_domain), </span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;velocity_dynamics_parameter&#39;</span>, <span class="op">*</span>velocity_dynamics_domain),</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>           ContinuousParameter(<span class="st">&#39;action_dynamics_parameter&#39;</span>, <span class="op">*</span>action_dynamics_domain)])</span></code></pre></div>
<p>Next, we evaluate the high and low fidelity simualtors at those locations.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mountain_car <span class="im">as</span> mc</span></code></pre></div>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>n_points <span class="op">=</span> <span class="dv">250</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>d_position_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>d_velocity_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>d_position_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>d_velocity_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Collect high fidelity points</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    d_position_hf[i], d_velocity_hf[i] <span class="op">=</span> mc.simulation(x_random[i, :])</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Collect low fidelity points  </span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    d_position_lf[i], d_velocity_lf[i] <span class="op">=</span> mc.low_cost_simulation(x_random[i, :])</span></code></pre></div>
<h2 id="prime-air">Prime Air</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ai/includes/prime-air-system.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ai/includes/prime-air-system.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>One project where the components of machine learning and the physical world come together is Amazon’s Prime Air drone delivery system.</p>
<p>Automating the process of moving physical goods through autonomous vehicles completes the loop between the ‘bits’ and the ‘atoms.’ In other words, the information and the ‘stuff.’ The idea of the drone is to complete a component of package delivery, the notion of last mile movement of goods, but in a fully autonomous way.</p>
<div class="centered" style="">
<svg viewBox="0 0 200 200" style="width:15%">
<defs> <clipPath id="clip1">
<style>
circle {
  fill: black;
}
</style>
<circle cx="100" cy="100" r="100"/> </clipPath> </defs>
<title>
Gur Kimchi
</title>
<image preserveAspectRatio="xMinYMin slice" width="100%" xlink:href="https://mlatcl.github.io/mlphysical/./slides/diagrams//people/gur-kimchi.png" clip-path="url(#clip1)"/>
</svg>
<svg viewBox="0 0 200 200" style="width:15%">
<defs> <clipPath id="clip2">
<style>
circle {
  fill: black;
}
</style>
<circle cx="100" cy="100" r="100"/> </clipPath> </defs>
<title>
Paul Viola
</title>
<image preserveAspectRatio="xMinYMin slice" width="100%" xlink:href="https://mlatcl.github.io/mlphysical/./slides/diagrams//people/paul-viola.png" clip-path="url(#clip2)"/>
</svg>
<svg viewBox="0 0 200 200" style="width:15%">
<defs> <clipPath id="clip3">
<style>
circle {
  fill: black;
}
</style>
<circle cx="100" cy="100" r="100"/> </clipPath> </defs>
<title>
David Moro
</title>
<image preserveAspectRatio="xMinYMin slice" width="100%" xlink:href="https://mlatcl.github.io/mlphysical/./slides/diagrams//people/david-moro.png" clip-path="url(#clip3)"/>
</svg>
</div>
<div class="figure">
<div id="amazon-drone-flight-figure" class="figure-frame">
<iframe width="600" height="450" src="https://www.youtube.com/embed/3HJtmx5f1Fc?start=" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<div id="amazon-drone-flight-magnify" class="magnify" onclick="magnifyFigure(&#39;amazon-drone-flight&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="amazon-drone-flight-caption" class="caption-frame">
<p>Figure: An actual ‘Santa’s sleigh.’ Amazon’s prototype delivery drone. Machine learning algorithms are used across various systems including sensing (computer vision for detection of wires, people, dogs etc) and piloting. The technology is necessarily a combination of old and new ideas. The transition from vertical to horizontal flight is vital for efficiency and uses sophisticated machine learning to achieve.</p>
</div>
</div>
<p>As Jeff Wilke (who was CEO of Amazon Retail at the time) <a href="https://blog.aboutamazon.com/transportation/a-drone-program-taking-flight">announced in June 2019</a> the technology is ready, but still needs operationalization including e.g. regulatory approval.</p>
<div class="figure">
<div id="jeff-wilke-remars-figure" class="figure-frame">
<iframe width="600" height="450" src="https://www.youtube.com/embed/wa8DU-Sui8Q?start=3767" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<div id="jeff-wilke-remars-magnify" class="magnify" onclick="magnifyFigure(&#39;jeff-wilke-remars&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="jeff-wilke-remars-caption" class="caption-frame">
<p>Figure: Jeff Wilke (CEO Amazon Consumer) announcing the new drone at the Amazon 2019 re:MARS event alongside the scale of the Amazon supply chain.</p>
</div>
</div>
<blockquote>
<p>When we announced earlier this year that we were evolving our Prime two-day shipping offer in the U.S. to a one-day program, the response was terrific. But we know customers are always looking for something better, more convenient, and there may be times when one-day delivery may not be the right choice. Can we deliver packages to customers even faster? We think the answer is yes, and one way we’re pursuing that goal is by pioneering autonomous drone technology.</p>
</blockquote>
<blockquote>
<p>Today at Amazon’s re:MARS Conference (Machine Learning, Automation, Robotics and Space) in Las Vegas, we unveiled our latest Prime Air drone design. We’ve been hard at work building fully electric drones that can fly up to 15 miles and deliver packages under five pounds to customers in less than 30 minutes. And, with the help of our world-class fulfillment and delivery network, we expect to scale Prime Air both quickly and efficiently, delivering packages via drone to customers within months.</p>
</blockquote>
<p>The 15 miles in less than 30 minutes implies air speed velocities of around 50 kilometers per hour.</p>
<blockquote>
<p>Our newest drone design includes advances in efficiency, stability and, most importantly, in safety. It is also unique, and it advances the state of the art. How so? First, it’s a hybrid design. It can do vertical takeoffs and landings – like a helicopter. And it’s efficient and aerodynamic—like an airplane. It also easily transitions between these two modes—from vertical-mode to airplane mode, and back to vertical mode.</p>
</blockquote>
<blockquote>
<p>It’s fully shrouded for safety. The shrouds are also the wings, which makes it efficient in flight.</p>
</blockquote>
<div class="figure">
<div id="amazon-prime-air-remars-figure" class="figure-frame">
<div class="centered centered" style="">
<img class="" src="https://mlatcl.github.io/mlphysical/./slides/diagrams//ai/amazon-prime-air-remars-june-2019.jpg" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="amazon-prime-air-remars-magnify" class="magnify" onclick="magnifyFigure(&#39;amazon-prime-air-remars&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="amazon-prime-air-remars-caption" class="caption-frame">
<p>Figure: Picture of the drone from Amazon Re-MARS event in 2019.</p>
</div>
</div>
<blockquote>
<p>Our drones need to be able to identify static and moving objects coming from any direction. We employ diverse sensors and advanced algorithms, such as multi-view stereo vision, to detect static objects like a chimney. To detect moving objects, like a paraglider or helicopter, we use proprietary computer-vision and machine learning algorithms.</p>
</blockquote>
<blockquote>
<p>A customer’s yard may have clotheslines, telephone wires, or electrical wires. Wire detection is one of the hardest challenges for low-altitude flights. Through the use of computer-vision techniques we’ve invented, our drones can recognize and avoid wires as they descend into, and ascend out of, a customer’s yard.</p>
</blockquote>
<h2 id="thanks">Thanks!</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/multifidelity.gpp.markdown" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/multifidelity.gpp.markdown', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>For more information on these subjects and more you might want to check the following resources.</p>
<ul>
<li>twitter: <a href="https://twitter.com/lawrennd">@lawrennd</a></li>
<li>podcast: <a href="http://thetalkingmachines.com">The Talking Machines</a></li>
<li>newspaper: <a href="http://www.theguardian.com/profile/neil-lawrence">Guardian Profile Page</a></li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Alvarez:thesis11" class="csl-entry" role="doc-biblioentry">
Álvarez, M.A., 2011. Convolved <span>G</span>aussian process priors for multivariate regression with applications to dynamical systems (PhD thesis). School of Computer Science, University of Manchester, Manchester, UK.
</div>
<div id="ref-Alvarez:llfm13" class="csl-entry" role="doc-biblioentry">
Álvarez, M.A., Luengo, D., Lawrence, N.D., 2013. Linear latent force models using <span>G</span>aussian processes. IEEE Transactions on Pattern Analysis and Machine Intelligence 35, 2693–2705. <a href="https://doi.org/10.1109/TPAMI.2013.86">https://doi.org/10.1109/TPAMI.2013.86</a>
</div>
<div id="ref-Alvarez:vector12" class="csl-entry" role="doc-biblioentry">
Álvarez, M.A., Rosasco, L., Lawrence, N.D., 2012. Kernels for vector-valued functions: A review. Foundations and Trends in Machine Learning 4, 195–266. <a href="https://doi.org/10.1561/2200000036">https://doi.org/10.1561/2200000036</a>
</div>
<div id="ref-Damianou:thesis2015" class="csl-entry" role="doc-biblioentry">
Damianou, A., 2015. Deep <span>G</span>aussian processes and variational propagation of uncertainty (PhD thesis). University of Sheffield.
</div>
<div id="ref-Damianou:deepgp13" class="csl-entry" role="doc-biblioentry">
Damianou, A., Lawrence, N.D., 2013. Deep <span>G</span>aussian processes. pp. 207–215.
</div>
<div id="ref-Dunlop:deep2017" class="csl-entry" role="doc-biblioentry">
Dunlop, M.M., Girolami, M.A., Stuart, A.M., Teckentrup, A.L., n.d. How deep are deep <span>G</span>aussian processes? Journal of Machine Learning Research 19, 1–46.
</div>
<div id="ref-Kennedy-predicting00" class="csl-entry" role="doc-biblioentry">
Kennedy, M.C., O’Hagan, A., 2000. Predicting the output from a complex computer code when fast approximations are available. Biometrika 87, 1–13.
</div>
<div id="ref-Lawrence:hgplvm07" class="csl-entry" role="doc-biblioentry">
Lawrence, N.D., Moore, A.J., 2007. Hierarchical <span>G</span>aussian process latent variable models. pp. 481–488.
</div>
<div id="ref-Lawrence:transcriptionalGP06" class="csl-entry" role="doc-biblioentry">
Lawrence, N.D., Sanguinetti, G., Rattray, M., n.d. Modelling transcriptional regulation using <span>G</span>aussian processes. pp. 785–792.
</div>
<div id="ref-Perdikaris:multifidelity17" class="csl-entry" role="doc-biblioentry">
Perdikaris, P., Raissi, M., Damianou, A., Lawrence, N.D., Karniadakis, G.E., 2017. Nonlinear information fusion algorithms for data-efficient multi-fidelity modelling. Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences 473. <a href="https://doi.org/10.1098/rspa.2016.0751">https://doi.org/10.1098/rspa.2016.0751</a>
</div>
<div id="ref-Pedikaris:nonlinear17" class="csl-entry" role="doc-biblioentry">
Perdikaris, Paris, Raissi, M., Damianou, A., Lawrence, N.D., Karnidakis, G.E., 2017. Nonlinear information fusion algorithms for data-efficient multi-fidelity modelling. Proc. R. Soc. A 473. <a href="https://doi.org/10.1098/rspa.2016.0751">https://doi.org/10.1098/rspa.2016.0751</a>
</div>
<div id="ref-Shahriari-human16" class="csl-entry" role="doc-biblioentry">
Shahriari, B., Swersky, K., Wang, Z., Adams, R.P., de Freitas, N., 2016. Taking the human out of the loop: A review of <span>B</span>ayesian optimization. Proceedings of the IEEE 104, 148–175. <a href="https://doi.org/10.1109/JPROC.2015.2494218">https://doi.org/10.1109/JPROC.2015.2494218</a>
</div>
</div>

